% =========================================================================
% Pareto 3D (t, T_avg, plating_cap) for: CCCV + MSCC2 + MSCC4
% - run_* 폴더에서 각 로그를 읽어서
%   3D 파레토(최소화: t, T_avg, plating_cap) 그림 저장
% - 그림 저장 경로: G:\...\COMSOL\Figure\pareto_YYYYMMDD_HHMMSS\pareto3D_*.png
% - 토글: 최신 run_* 자동 선택 vs 대화형 선택 (use_latest)
% =========================================================================
clc; clear; close all;

%% 0) 입력/출력 경로 --------------------------------------------------------
base_dir = 'G:\공유 드라이브\Battery Software Group (2025)\Members\최은식\COMSOL\MSCC_optimization\MSCC_CCCV_opt';
assert(isfolder(base_dir), '기본 폴더 없음: %s', base_dir);

% === 토글 스위치: true면 최신 run_* 자동선택, false면 대화형 선택 ===
use_latest = false;

% Figure 저장 루트
fig_base_dir = 'G:\공유 드라이브\Battery Software Group (2025)\Members\최은식\COMSOL\Figure';
assert(isfolder(fileparts(fig_base_dir)) || isfolder(fig_base_dir), 'Figure 상위 폴더가 유효하지 않습니다.');
ts = datestr(now,'yyyymmdd_HHMMSS');
fig_out_dir = fullfile(fig_base_dir, ['pareto_' ts]);
if ~isfolder(fig_out_dir), mkdir(fig_out_dir); end

%% 1) run_* 폴더 선택 -------------------------------------------------------
if use_latest
    d = dir(fullfile(base_dir, 'run_*'));
    assert(~isempty(d), 'run_* 폴더가 없습니다. 먼저 최적화 스크립트를 실행하세요.');
    [~,ix] = max([d.datenum]);
    run_dir = fullfile(base_dir, d(ix).name);
else
    run_dir = uigetdir(base_dir, '분석할 run_* 폴더를 선택하세요');
    if isstring(run_dir), run_dir = char(run_dir); end
    assert(~isequal(run_dir,0), '폴더 선택이 취소되었습니다.');
    [~,selname] = fileparts(run_dir);
    assert(startsWith(selname,'run_'), '선택한 폴더명이 run_* 형식이 아닙니다: %s', selname);
end

fprintf('Using run dir: %s\n', run_dir);

%% 2) 로그 파일 경로 지정 (3종류: CCCV, MSCC2, MSCC4) ----------------------
cccv_log  = pick_one_file(run_dir, 'cccv_optimization_log_*.csv');
mscc2_log = pick_one_file(run_dir, 'mscc2_optimization_log_*.csv');
mscc4_log = pick_one_file(run_dir, 'mscc4_optimization_log_*.csv');

fprintf('  CCCV  log: %s\n',  cccv_log);
fprintf('  MSCC2 log: %s\n', mscc2_log);
fprintf('  MSCC4 log: %s\n', mscc4_log);

%% 3) 데이터 로드 & 컬럼 체크 ----------------------------------------------
TC  = readtable(cccv_log);
TM2 = readtable(mscc2_log);
TM4 = readtable(mscc4_log);

% Pareto용 필요한 컬럼: t, T_avg, plating_cap, s(=min(liion.Ect))
needCols = {'t','T_avg','plating_cap','s'};
assert(all(ismember(needCols, TC.Properties.VariableNames )), 'CCCV 로그에 t/T_avg/plating_cap/s 컬럼이 없습니다.');
assert(all(ismember(needCols, TM2.Properties.VariableNames)), 'MSCC2 로그에 t/T_avg/plating_cap/s 컬럼이 없습니다.');
assert(all(ismember(needCols, TM4.Properties.VariableNames)), 'MSCC4 로그에 t/T_avg/plating_cap/s 컬럼이 없습니다.');

% 색상 팔레트 (CCCV, MSCC2, MSCC4)
blue    = [0,115,194]/255;   % CCCV
purple  = [128,0,128]/255;   % MSCC2
red     = [205,83,76]/255;   % MSCC4

% 데이터셋 패킹 (t, T_avg, plating_cap, s)
DS = struct('name',{},'t',{},'T',{},'pc',{},'s',{},'color',{});
DS(end+1) = struct('name','CCCV',  't',TC.t,  'T',TC.T_avg,  'pc',TC.plating_cap,  's',TC.s,  'color',blue);
DS(end+1) = struct('name','MSCC2', 't',TM2.t, 'T',TM2.T_avg, 'pc',TM2.plating_cap, 's',TM2.s, 'color',purple);
DS(end+1) = struct('name','MSCC4', 't',TM4.t, 'T',TM4.T_avg, 'pc',TM4.plating_cap, 's',TM4.s, 'color',red);

%% 4) 3D Pareto — t vs plating_cap vs T_avg(°C) + 제약 표시 -----------------
for k = 1:numel(DS)

    name = DS(k).name;
    t    = DS(k).t;
    Tavg = DS(k).T - 273.15;      % ★ K → °C
    pc   = DS(k).pc;              % plating_cap
    s    = DS(k).s;               % min(liion.Ect)

    % ===== 제약 설정 (네 최적화 조건과 동일하게 맞춰라) =====
    safety_eps  = 0.0;       % min(Ect) > safety_eps
    plating_eps = 0.0002;      % plating_cap upper bound

    feas   = (s > safety_eps) & (pc <= plating_eps);
    infeas = ~feas;

    % ===== Pareto: 전체 trial에서 계산 (feasible만 아님) =====
    F = [t, Tavg, pc];             
    mask_nd = isNondominatedND(F); 

    % ===== Plot =====
    f = figure(2000+k); clf; hold on; grid on; view(45,25); set(gcf,'Color','w');
    title(sprintf('Pareto 3D — t vs plating\\_cap vs T_{avg} (°C) (%s)', name));

    % infeasible (빨간 x)
    scatter3(t(infeas), pc(infeas), Tavg(infeas), 20, ...
        [0.9 0.3 0.3], 'x', 'LineWidth',1.4, ...
        'DisplayName',[name ' infeasible']);

    % feasible (연파랑 투명 점)
    scatter3(t(feas), pc(feas), Tavg(feas), 20, ...
        [0.4 0.6 1], 'filled', 'MarkerFaceAlpha',0.25, ...
        'DisplayName',[name ' feasible']);

    % Pareto front (굵은 파랑 동그라미)
    scatter3(t(mask_nd), pc(mask_nd), Tavg(mask_nd), 60, 'o', ...
        'MarkerEdgeColor',[0 0.4 1], 'LineWidth',1.8, ...
        'DisplayName',[name ' Pareto']);

    xlabel('t (s)');
    ylabel('plating\_cap (Ah/m^2)');
    zlabel('T_{avg} (°C)');
    legend('Location','best');

    % 저장
    out_png = fullfile(fig_out_dir, sprintf('pareto3D_%s_platingCap.png', name));
    export_png(f, out_png);
    fprintf('Saved: %s\n', out_png);

end

%% ====================== 최적 C-rate 시뮬레이션 ============================
fprintf('\n[SIM] 최적 C-rate 시뮬레이션 (liion.Ect) 시작\n');

import com.comsol.model.*
import com.comsol.model.util.*
ModelUtil.showProgress(true);

% 5.1) 최적해 요약 MAT 로드
summary_mat = pick_one_file(run_dir, 'run_summary_*.mat');
S = load(summary_mat);

% --- 최적 C-rate (전부 summary에서 읽음) ----------------------------------
C_cccv  = S.optimal_C_rate;        % scalar
C_mscc2 = S.optimal_C_mscc2(:).';  % [C12 C3456]
C_mscc4 = S.optimal_C_mscc4(:).';  % [C1 C2 C34 C56]

% --- 각 프로토콜별 최적 충전 시간 [s] ------------------------------------
t_cccv  = S.cccv_min_t;
t_mscc2 = S.mscc2_min_t;
t_mscc4 = S.mscc4_min_t;

% 5.2) 모델 로드 ------------------------------------------------------------
filepath = 'C:\Users\dsdsd\Downloads';
filename = 'ES_MSCCPC_Final_1119_pulse.mph';
full_path = fullfile(filepath, filename);
assert(isfile(full_path),'mph 파일 없음: %s', full_path);
model = mphload(full_path);

% (※ 여기서는 더 이상 모델 파라미터에서 C-rate를 읽지 않는다.
%     위에서 summary 기반 C_mscc4를 그대로 사용)

% 5.4) 실행 (프로토콜당 1회 실행, tlist = range(0,10,t_cycling))
fprintf('\n[SIM] Running CCCV...\n');
R_cccv  = run_and_eval('CCCV',  model, C_cccv,  t_cccv);

fprintf('\n[SIM] Running MSCC2...\n');
R_mscc2 = run_and_eval('MSCC2', model, C_mscc2, t_mscc2);

fprintf('\n[SIM] Running MSCC4...\n');
R_mscc4 = run_and_eval('MSCC4', model, C_mscc4, t_mscc4);

%% 5.5) 색상 (위 파레토 팔레트와 동일)
blue    = [0,115,194]/255;   % CCCV
purple  = [128,0,128]/255;   % MSCC2
red     = [205,83,76]/255;   % MSCC4

%% 5.1) Figure 1 — 전압/전류 vs time (yyaxis)
f1 = figure(4101); clf; set(gcf,'Color','w'); hold on; grid on;
title('Voltage & Current vs time (Optimal C)');

yyaxis left;
plot(R_cccv.t,  R_cccv.E,  '-',  'LineWidth',1.5, 'Color',blue);
plot(R_mscc2.t, R_mscc2.E, '-',  'LineWidth',1.5, 'Color',purple);
plot(R_mscc4.t, R_mscc4.E, '-',  'LineWidth',1.5, 'Color',red);
ylabel('E_{cell} (V)');

yyaxis right;
plot(R_cccv.t,  R_cccv.I,  '--', 'LineWidth',1.2, 'Color',blue);
plot(R_mscc2.t, R_mscc2.I, '--', 'LineWidth',1.2, 'Color',purple);
plot(R_mscc4.t, R_mscc4.I, '--', 'LineWidth',1.2, 'Color',red);
ylabel('I_{cell} (A)');

xlabel('t (s)');
legend({'E CCCV','E MSCC2','E MSCC4', ...
        'I CCCV','I MSCC2','I MSCC4'}, ...
        'Location','bestoutside');

% 축 색을 모두 검정으로
ax = gca;
ax.XColor      = 'k';
ax.YAxis(1).Color = 'k';
ax.YAxis(2).Color = 'k';

export_png(f1, fullfile(fig_out_dir, 'timeseries_voltage_current.png'));

%% 5.2) Figure 2 — (liion.Ect) vs time
f2 = figure(4102); clf; set(gcf,'Color','w'); hold on; grid on;
plot(R_cccv.t,  R_cccv.vdiff,  'LineWidth',1.6, 'Color',blue);
plot(R_mscc2.t, R_mscc2.vdiff, 'LineWidth',1.6, 'Color',purple);
plot(R_mscc4.t, R_mscc4.vdiff, 'LineWidth',1.6, 'Color',red);
xlabel('t (s)');
ylabel('Anode potential (V)');
title('Anode potential vs time (Optimal C)');
legend({'CCCV','MSCC2','MSCC4'}, 'Location','best');

ax = gca;
ax.XColor = 'k';
ax.YColor = 'k';

export_png(f2, fullfile(fig_out_dir, 'timeseries_anode_potential.png'));

%% 5.3) Figure 3 — T_{avg}, T_{max} vs time [°C]
f3 = figure(4103); clf; set(gcf,'Color','w'); hold on; grid on;

% 각 프로토콜 별 K -> °C 변환
TavgC_cccv  = R_cccv.Tavg  - 273.15;
TavgC_mscc2 = R_mscc2.Tavg - 273.15;
TavgC_mscc4 = R_mscc4.Tavg - 273.15;

TmaxC_cccv  = R_cccv.Tmax  - 273.15;
TmaxC_mscc2 = R_mscc2.Tmax - 273.15;
TmaxC_mscc4 = R_mscc4.Tmax - 273.15;

% T_avg (°C)
plot(R_cccv.t,  TavgC_cccv,  '-',  'LineWidth',1.6, 'Color',blue);
plot(R_mscc2.t, TavgC_mscc2, '-',  'LineWidth',1.6, 'Color',purple);
plot(R_mscc4.t, TavgC_mscc4, '-',  'LineWidth',1.6, 'Color',red);

% T_max (°C)
plot(R_cccv.t,  TmaxC_cccv,  '--', 'LineWidth',1.4, 'Color',blue);
plot(R_mscc2.t, TmaxC_mscc2, '--', 'LineWidth',1.4, 'Color',purple);
plot(R_mscc4.t, TmaxC_mscc4, '--', 'LineWidth',1.4, 'Color',red);

xlabel('t (s)');
ylabel('Temperature (°C)');
title('Temperature vs time (Optimal C)');
legend({'T_{avg} CCCV','T_{avg} MSCC2','T_{avg} MSCC4', ...
        'T_{max} CCCV','T_{max} MSCC2','T_{max} MSCC4'}, ...
        'Location','bestoutside');

ax = gca;
ax.XColor = 'k';
ax.YColor = 'k';

export_png(f3, fullfile(fig_out_dir, 'timeseries_temperature.png'));

%% 프로토콜 리스트 (이후 플롯용) -------------------------------------------
PROT = struct('name',{},'R',{},'color',{});
PROT(end+1) = struct('name','CCCV',  'R',R_cccv,  'color',blue);
PROT(end+1) = struct('name','MSCC2', 'R',R_mscc2, 'color',purple);
PROT(end+1) = struct('name','MSCC4', 'R',R_mscc4, 'color',red);

%% 5.4) Voltage & Current vs time — 프로토콜별 개별 플롯 -------------------
for k = 1:numel(PROT)
    P = PROT(k);
    R = P.R;

    fV = figure(4200+k); clf;
    set(gcf,'Color','w');
    grid off; hold on;

    title(sprintf('Voltage & Current vs time (Optimal C, %s)', P.name));

    yyaxis left;
    plot(R.t, R.E, '-', 'LineWidth',1.5, 'Color',[0 0.6 0]);   % green
    ylabel('E_{cell} (V)');

    yyaxis right;
    plot(R.t, R.I, '--', 'LineWidth',1.2, 'Color',[0.5 0 0.5]); % purple
    ylabel('I_{cell} (A)');

    xlabel('t (s)');
    legend({'E_{cell}','I_{cell}'}, 'Location','best');

    % 축 색 검정
    ax = gca;
    ax.XColor        = 'k';
    ax.YAxis(1).Color = 'k';
    ax.YAxis(2).Color = 'k';

    hold off;

    out_png = fullfile(fig_out_dir, ...
        sprintf('timeseries_voltage_current_%s.png', P.name));
    export_png(fV, out_png);
end

%% 5.5) Temperature vs time — 프로토콜별 개별 플롯 (T_{avg}, T_{max}) [°C]
for k = 1:numel(PROT)
    P = PROT(k);
    R = P.R;

    % K -> °C 변환
    TavgC = R.Tavg - 273.15;
    TmaxC = R.Tmax - 273.15;

    fT = figure(4300+k); clf;
    set(gcf,'Color','w');
    grid off; hold on;

    title(sprintf('Temperature vs time (Optimal C, %s)', P.name));

    % T_avg: 파란색 실선 (°C)
    plot(R.t, TavgC, '-',  'LineWidth',1.6, 'Color',blue);
    % T_max: 빨간색 점선 (°C)
    plot(R.t, TmaxC, '--', 'LineWidth',1.4, 'Color',red);

    xlabel('t (s)');
    ylabel('Temperature (°C)');
    legend({'T_{avg}','T_{max}'}, 'Location','best');

    ax = gca;
    ax.XColor = 'k';
    ax.YColor = 'k';

    hold off;

    out_png = fullfile(fig_out_dir, ...
        sprintf('timeseries_temperature_%s.png', P.name));
    export_png(fT, out_png);
end

%% 5.6) Anode potential vs time — 프로토콜별 개별 플롯 ----------------------
for k = 1:numel(PROT)
    P = PROT(k);
    R = P.R;

    fA = figure(4400+k); clf;
    set(gcf,'Color','w');
    grid off; hold on;

    plot(R.t, R.vdiff, 'LineWidth',1.6, 'Color', P.color);

    xlabel('t (s)');
    ylabel('Anode potential (V)');
    title(sprintf('Anode potential vs time (Optimal C, %s)', P.name));
    legend({P.name}, 'Location','best');

    ax = gca;
    ax.XColor = 'k';
    ax.YColor = 'k';

    hold off;

    out_png = fullfile(fig_out_dir, ...
        sprintf('timeseries_anode_potential_%s.png', P.name));
    export_png(fA, out_png);
end

%% 5.7) Thermal load metrics — ∫ΔT dt, ∫Qh dt per protocol -----------------
%  - Thermal burden:  J_T = ∫ (Tavg(t) - T_init) dt     [K·s ≒ °C·s]
%  - Heat generation: J_Q = ∫ Qh(t) dt                  [J/m^3]  (Qh: W/m^3)

nP     = numel(PROT);
names  = {PROT.name};
colors = vertcat(PROT.color);

J_T = zeros(nP,1);   % ∫ΔT dt
J_Q = zeros(nP,1);   % ∫Qh dt

for k = 1:nP
    R = PROT(k).R;

    t    = R.t(:);
    Tavg = R.Tavg(:);
    Qh   = R.Qh(:);

    % 각 프로토콜 자기 초기온도를 기준으로 ΔT 계산
    T_init = Tavg(1);

    dT = Tavg - T_init;          % [K]
    J_T(k) = trapz(t, dT);       % [K·s] ≒ [°C·s]
    J_Q(k) = trapz(t, Qh);       % [J/m^3]  (Qh: W/m^3 → 시간적분)
end

% --- (1) ∫ΔT dt bar plot --------------------------------------------------
fDT = figure(4501); clf; set(gcf,'Color','w');
b1 = bar(J_T);
b1.FaceColor = 'flat';
for k = 1:nP
    b1.CData(k,:) = colors(k,:);
end
grid on;

xticks(1:nP);
xticklabels(names);
xlabel('Protocol');
ylabel('\int \DeltaT_{avg}(t)\, dt  (°C·s)');
title('Thermal burden: \int (T_{avg}(t) - T_{init}) dt (Optimal C)');
set(gca,'FontSize',11);

out_DT = fullfile(fig_out_dir, 'thermal_JT_integral_deltaTavg.png');
export_png(fDT, out_DT);
fprintf('Saved: %s\n', out_DT);

% --- (2) ∫Qh dt bar plot --------------------------------------------------
fQh = figure(4502); clf; set(gcf,'Color','w');
b2 = bar(J_Q);
b2.FaceColor = 'flat';
for k = 1:nP
    b2.CData(k,:) = colors(k,:);
end
grid on;

xticks(1:nP);
xticklabels(names);
xlabel('Protocol');
ylabel('\int Q_h(t)\, dt  (J/m^3)');
title('Total heat generation: \int Q_h(t) dt (Optimal C)');
set(gca,'FontSize',11);

out_Qh = fullfile(fig_out_dir, 'thermal_JQ_integral_Qh.png');
export_png(fQh, out_Qh);
fprintf('Saved: %s\n', out_Qh);

%% 5.8) plating_cap vs time — 프로토콜별 개별 플롯 --------------------------
for k = 1:numel(PROT)
    P = PROT(k);
    R = P.R;

    fP = figure(4600+k); clf;
    set(gcf,'Color','w');
    grid on; hold on;

    plot(R.t, R.pc, 'LineWidth',1.6, 'Color', P.color);

    xlabel('t (s)');
    ylabel('plating\_cap (Ah/m^2)');
    title(sprintf('Plating capacity vs time (Optimal C, %s)', P.name));
    legend({P.name}, 'Location','best');

    ax = gca;
    ax.XColor = 'k';
    ax.YColor = 'k';

    out_png = fullfile(fig_out_dir, ...
        sprintf('timeseries_platingcap_%s.png', P.name));
    export_png(fP, out_png);
end

%% ======================= Local helper functions ==========================
function fpath = pick_one_file(folder, pattern)
    L = dir(fullfile(folder, pattern));
    assert(~isempty(L), '파일이 없습니다: %s', fullfile(folder, pattern));
    [~,ix] = max([L.datenum]);           % 가장 최신 파일
    fpath = fullfile(L(ix).folder, L(ix).name);
end

function export_png(fig_handle, outpath)
    try
        set(fig_handle, 'Color','w');
        axs = findall(fig_handle, 'Type', 'axes');
        for ax = axs'
            try, axtoolbar(ax,'Visible','off'); end %#ok<TRYNC>
        end
        exportgraphics(fig_handle, outpath, 'Resolution', 220);
    catch ME
        warning('PNG 저장 실패 (%s): %s', outpath, ME.message);
    end
end

function mask_nd = isNondominatedND(F)
% F: [N x M], 각 열은 "최소화" 대상.
% 반환: 비지배(true)/지배(false)
    N = size(F,1);
    mask_nd = true(N,1);
    for i = 1:N
        if ~mask_nd(i), continue; end
        for j = 1:N
            if i==j, continue; end
            if all(F(j,:) <= F(i,:)) && any(F(j,:) < F(i,:))
                mask_nd(i) = false;
                break;
            end
        end
    end
end

function R = run_and_eval(protocol, model, Cvals, t_cycling)
    % run_and_eval
    %   - protocol : 'CCCV', 'MSCC2', 'MSCC4'
    %   - Cvals    : 해당 프로토콜의 최적 C-rate 벡터
    %   - t_cycling: run_summary 에서 읽어온 최적 충전시간 [s]
    %
    % 여기서 dt_out 은 COMSOL Output times 의 두 번째 인자에 해당 (예: range(0,10,t_cycling))
    dt_out = 10;   % [s]

    % ===== (1) 파라미터 세팅 & 스터디/데이터셋 선택 =====
    switch protocol
        case 'CCCV'
            model.param.set('C_rate', num2str(Cvals(1)));
            studyTag = 'std1'; dset = 'dset1';

        case 'MSCC2'   % [C12 C3456]
            C12    = Cvals(1);
            C3456  = Cvals(2);
            model.param.set('first_MSCC_Crate',  num2str(C12));
            model.param.set('second_MSCC_Crate', num2str(C12));
            model.param.set('third_MSCC_Crate',  num2str(C3456));
            model.param.set('fourth_MSCC_Crate', num2str(C3456));
            model.param.set('fifth_MSCC_Crate',  num2str(C3456));
            model.param.set('sixth_MSCC_Crate',  num2str(C3456));
            studyTag = 'std2'; dset = 'dset3';

        case 'MSCC4'   % [C1 C2 C34 C56]
            C1 = Cvals(1); C2 = Cvals(2); C34 = Cvals(3); C56 = Cvals(4);
            model.param.set('first_MSCC_Crate',  num2str(C1));
            model.param.set('second_MSCC_Crate', num2str(C2));
            model.param.set('third_MSCC_Crate',  num2str(C34));
            model.param.set('fourth_MSCC_Crate', num2str(C34));
            model.param.set('fifth_MSCC_Crate',  num2str(C56));
            model.param.set('sixth_MSCC_Crate',  num2str(C56));

            model.param.set('pulse_stage_mode', '0');
            studyTag = 'std2'; dset = 'dset3';

        otherwise
            error('Unknown protocol');
    end

    % ---- (1-1) 최적 시간 t_cycling 파라미터 세팅 ----
    model.param.set('t_cycling', num2str(t_cycling));

    % ---- (1-2) Output times = range(0, dt_out, t_cycling) 로 세팅 ----
    tlist_str = sprintf('range(0,%g,t_cycling)', dt_out);
    set_tlist_safe(model, studyTag, tlist_str);

    % ===== (2) 단일 실행 =====
    model.study(studyTag).run();

    % ===== (3) 데이터 취득 =====
    expr = {'t','E_cell','liion.cdc1.Icell','liion.Ect','T_avg','T_max', ...
            'liion.cdc1.CC_CH','liion.cdc1.CV_CH', ...
            'liion.Qh','plating_cap'};   % Qh, plating_cap 포함
    D = mpheval(model, expr, 'dataset',dset,'edim','point','selection',2,'solnum','all');

    t  = D.d1;  E  = D.d2;  I  = D.d3;  v = D.d4;
    Ta = toCol(D,5); Tm = toCol(D,6);
    cc = D.d7;  cv = D.d8;
    Qh = toCol(D,9);    % Qh 시계열
    pc = toCol(D,10);   % plating_cap 시계열

    idx = (cc==1) | (cv==1);
    if ~any(idx), idx = true(size(t)); end

    R = struct('t',t(idx),'E',E(idx),'I',I(idx), ...
           'vdiff',v(idx),'Tavg',Ta(idx),'Tmax',Tm(idx), ...
           'Qh',Qh(idx),'pc',pc(idx));
end

function col = toCol(D, k)
    try
        col = D.(['d' num2str(k)]);
    catch
        col = nan(size(D.d1));
    end
end

function set_tlist_safe(model, studyTag, tlist_str)
    tried = false;
    for cand = {'time','time1','time2','step1','step2'}
        try
            model.study(studyTag).feature(char(cand)).set('tlist', tlist_str);
            tried = true;
            break;
        catch
        end
    end
    for solCand = {'sol1','sol2'}
        for featCand = {'t1','t2','time','time1'}
            try
                model.sol(char(solCand)).feature(char(featCand)).set('tlist', tlist_str);
            catch
            end
        end
    end
    if ~tried
        warning('tlist 설정 실패: study=%s (기본 설정으로 계속 진행)', studyTag);
    end
end
